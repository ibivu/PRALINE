"""Convenience methods and classes related to component execution by user
code and other components.

.. moduleauthor:: Maurits Dijkstra <mauritsdijkstra@gmail.com>

"""

from collections import OrderedDict
from uuid import uuid4 as uuid

from component import MESSAGE_KIND_BEGIN, MESSAGE_KIND_COMPLETE
from component import MESSAGE_KIND_LOG, MESSAGE_KIND_PROGRESS
from component import Environment
from exception import *

class TaskNode(object):
    """A node in a component execution graph. This graph is constructed
    by watching the messages generated during the execution of a task.
    Because we can see when a component spawns another component we can
    build a tree containing the state of the current (and completed)
    component execution contexts. This is in turn useful for showing
    the status of the task execution (in the command-line programs) or
    for other state queries.

    :param tag: a string uniquely identifying the component execution context
        corresponding to this node in the tree
    :param children: dict containing an initial set of children for this node
    :param progress: float value with the initial progress for this node
    :param log_url: string URL with the location of the log bundle for this
        node

    """
    def __init__(self, tag, children=None, progress=None, log_url=None):
        self.tag = tag
        if children is None:
            self.children = OrderedDict()
        else:
            self.children = OrderedDict(children)
        if progress is None:
            self.progress = 0.0
        else:
            self.progress = progress
        self.log_url = log_url
        self.complete = False

    def update(self, msg):
        """Update the tree according to the event specified by a message.
        If the message provided wasn't generated by the component execution
        context corresponding to this node then it is propagated to
        children of this node.

        :param msg: update the state of the tree according to this message

        """
        if msg.kind == MESSAGE_KIND_BEGIN:
            if self.tag == msg.parent_tag:
                self.children[msg.tag] = TaskNode(msg.tag)
            else:
                self._propagate(msg)
        elif msg.kind == MESSAGE_KIND_COMPLETE:
            if self.tag == msg.tag:
                self.finish()
            else:
                self._propagate(msg)
        elif msg.kind == MESSAGE_KIND_PROGRESS:
            if self.tag == msg.tag:
                self.progress = msg.progress
            else:
                self._propagate(msg)
        elif msg.kind == MESSAGE_KIND_LOG:
            if self.tag == msg.tag:
                self.log_url = msg.url
            else:
                self._propagate(msg)

    def finish(self):
        """Mark the execution context corresponding to this node as having
        completed. Propagates along to the children of this node, as
        component execution is hierarchical, meaning that this execution
        can't finish until all of the subcontexts it started have completed.

        """
        self.complete = True
        for node in self.children.itervalues():
            node.finish()

    def _propagate(self, msg):
        """Propagate a message along to child nodes.

        :param msg: the message to propagate to the children of this node

        """
        for node in self.children.itervalues():
            if not node.complete:
                node.update(msg)

    def num_leaves(self, level=-1):
        """Recursively enumerate the nodes in the tree, starting with this
        node. Does not include this node itself in the count.

        """
        if level >= 0:
            acc = 1
        else:
            acc = 0

        for node in self.children.itervalues():
            if not node.complete:
                acc += node.num_leaves(level=level + 1)

        return acc


class Execution(object):
    """Convenience object corresponding to a (sub)task to be executed by
    user code or another component. Although it is generally possible to
    call the manager methods yourself it is preferred to use this class as
    it handles most of the heavy lifting of specifying inputs and collecting
    outputs for you.

    :param manager: the manager to execute this task on
    :param parent_tag: string uniquely identifying the parent execution
        context
    :param strip_bulk_data: boolean signifying whether bulk data should
        be stripped from some message types during execution -- you generally
        want this because you're not interested in the full output of some
        subtask you did not start and only want to know it has completed

    """
    def __init__(self, manager, parent_tag = None, strip_bulk_data = True):
        self.manager = manager
        self._tasks = []
        self.parent_tag = parent_tag
        self._outputs = None
        self._done = False
        self.strip_bulk_data = strip_bulk_data
        self._tags = set()

    def add_task(self, component):
        """Create a task object to execute and add it to this execution.

        :param component: a string identifying the component to execute
        :returns: the task object corresponding to the created task

        """
        tag = _generate_tag(component.tid)
        self._tags.add(tag)
        task = Task(self, component, tag)
        self._tasks.append(task)

        return task

    def run(self):
        """Run all the tasks in this execution. Messages generated during
        execution are yielded by this method and can be passed along to, for
        example, build a task tree.

        """
        tag_idx_map = {}
        reqs = []
        self._outputs = [None for x in xrange(len(self._tasks))]

        task_iter = enumerate(t.get() for t in self._tasks)
        for i, (component, env, inputs, tag) in task_iter:
            tag_idx_map[tag] = i
            req = (component.tid, inputs, tag, env)
            reqs.append(req)


        for message in self.manager.execute_many(reqs, self.parent_tag):
            if message.kind == MESSAGE_KIND_COMPLETE:
                try:
                    i = tag_idx_map[message.tag]
                    self._outputs[i] = message.outputs
                except KeyError:
                    pass

                if self.strip_bulk_data:
                    message.outputs = None

            yield message

        self._done = True


    def started_task(self, tag):
        """Determine whether this execution instance is directly responsible
        for starting the task with the provided tag. This is useful when
        you're trying to keep track of execution progress and you want
        to know which completion messages belong to tasks directly started
        by the execution instance.

        :param tag: the tag of the task
        :returns: True if the execution instance is responsible for starting
                  this task, False otherwise

        """
        return tag in self._tags

    @property
    def outputs(self):
        """Property getter to access the outputs of the tasks of an
        execution. Note that this cannot be accessed until this execution
        has completed. If you do attempt to do so an exception will be
        raised.

        """
        if not self._done:
            s = "cannot access outputs until all messages have been " \
                "consumed from Execution.run()"
            raise ComponentError(s)

        return self._outputs


class Task(object):
    """A class representing a single task within an execution.

    :param execution: the execution object this task belongs to
    :param component: a type id string with the component to execute

    """
    def __init__(self, execution, component, tag):
        self.tag = tag
        self._execution = execution
        self._component = component
        self._inputs = None
        self._env = None
        self._root_env = None

    def inputs(self, **kwargs):
        """Set the inputs for this execution task. Returns the task,
        so this call can be chained. Inputs are provided as keyword
        arguments.

        :returns: this task

        """
        if self._inputs is None:
            self._inputs = {}

        for k, v in kwargs.iteritems():
            self._inputs[k] = v

        return self

    def environment(self, root_env=None, env=None):
        """Set the parent environment and the child environment for this
        execution task. Returns this task, so this call can be chained.

        :params root_env: the parent environment object
        :params env: the child environment object
        :returns: this task

        """

        self._root_env = root_env
        self._env = env

        return self

    def get(self):
        """Collect the information contained in this task object. This is
        called by the execution when it is executed. Will raise an exception
        when required information is missing from the task.

        :returns: a 3-tuple containing the component type id, the collapsed
            environment and the inputs for this execution task
        """

        if self._inputs is None:
            s = "please provide inputs for this execution task"
            raise ComponentError(s)

        if self._env is None:
            env = Environment({})
        else:
            env = self._env
        if self._root_env is None:
            root_env = Environment({})
        else:
            root_env = self._root_env
        collapsed_env = root_env.collapse(self._component, env)

        return self._component, collapsed_env, self._inputs, self.tag


def _generate_tag(tid):
    """Helper method to generate a tag for a component execution context.
    Will generate a tag containing the classname of the component and a
    hex representation of a 128-bit UUID value, separated by a hash character.

    :param component: string containing the component type id
    :returns: string tag in the format described above

    """
    classname = tid.split(".")[-1]

    return "{0}#{1}".format(classname, uuid().hex)
